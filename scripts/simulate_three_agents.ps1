<#
Simple three-agent simulation. Reads .continue/backlog_proposal.json (generated by the backlog prototype),
creates three simulated agents with varied skill profiles, assigns tasks by simple keyword-skill matching
and agent capacity, and writes results to .continue/three_agent_simulation.json and .continue/three_agent_assignments.txt.

Usage:
  powershell -NoProfile -File .\scripts\simulate_three_agents.ps1 [-CapacityOverride <int>]
#>

param(
  [int]$CapacityOverride = 0
)

Set-StrictMode -Version Latest

$root = Get-Location
$backlogPath = Join-Path $root '.continue\backlog_proposal.json'
if (-not (Test-Path $backlogPath)) {
  Write-Error "Backlog not found at $backlogPath. Run the backlog generator first."
  exit 1
}

$backlog = Get-Content $backlogPath -Raw | ConvertFrom-Json
$items = @()
if ($backlog.backlog) { $items = $backlog.backlog } elseif ($backlog.items) { $items = $backlog.items }
if (-not $items) { Write-Error "No backlog items found in $backlogPath"; exit 1 }

# Define three agents with varied skill profiles
$agents = @(
  @{ name = 'Agent-A'; capacity = 8; assignedPoints = 0; skills = @{ CreateBacklog=5; Prioritization=4; Assignment=3; StatusUpdate=4; Reporting=3; Simulation=3; Storage=5; UI=2; API=2; Automation=4 } },
  @{ name = 'Agent-B'; capacity = 6; assignedPoints = 0; skills = @{ CreateBacklog=3; Prioritization=5; Assignment=4; StatusUpdate=3; Reporting=4; Simulation=2; Storage=3; UI=4; API=3; Automation=3 } },
  @{ name = 'Agent-C'; capacity = 5; assignedPoints = 0; skills = @{ CreateBacklog=2; Prioritization=3; Assignment=5; StatusUpdate=2; Reporting=2; Simulation=4; Storage=2; UI=3; API=5; Automation=2 } }
)

if ($CapacityOverride -gt 0) {
  foreach ($a in $agents) { $a.capacity = $CapacityOverride }
}

# Keyword -> skill mapping (simple heuristic)
# keywords -> skill with base weight
$skillKeywords = @{
  'backlog' = @{skill='CreateBacklog'; weight=3}
  'todo'    = @{skill='CreateBacklog'; weight=3}
  'task'    = @{skill='CreateBacklog'; weight=2}
  'priorit' = @{skill='Prioritization'; weight=4}
  'assign'  = @{skill='Assignment'; weight=4}
  'status'  = @{skill='StatusUpdate'; weight=3}
  'report'  = @{skill='Reporting'; weight=3}
  'simulate'= @{skill='Simulation'; weight=3}
  'db'      = @{skill='Storage'; weight=2}
  'store'   = @{skill='Storage'; weight=2}
  'ui'      = @{skill='UI'; weight=2}
  'api'     = @{skill='API'; weight=3}
  'automate'= @{skill='Automation'; weight=3}
}

# synonyms map (word fragment -> canonical keyword in skillKeywords)
$synonyms = @{
  'todo' = @('todo','todos','to-do')
  'backlog' = @('backlog','back-log')
  'priorit' = @('priority','prioritize')
  'assign' = @('assign','assignment','assigns')
  'automate' = @('automation','automate','automated')
}

function Get-ItemScoreForAgent($item, $agent) {
  $score = 0
  $title = ''
  $desc = ''
  if ($item.PSObject.Properties['title']) { $title = ($item.title -as [string]) }
  if ($item.PSObject.Properties['description']) { $desc = ($item.description -as [string]) }
  $text = ("$title $desc").ToLower()

  # count keyword hits and apply weights; support synonyms
  foreach ($kw in $skillKeywords.GetEnumerator()) {
    $key = $kw.Key
    $meta = $kw.Value
    $hits = 0
    # direct match via regex word fragment
    $re = [regex]::Escape($key)
    $hits += ([regex]::Matches($text, $re)).Count
    # synonyms
    foreach ($s in $synonyms.Keys) {
      if ($synonyms[$s] -contains $key -or $key -eq $s) {
        foreach ($alt in $synonyms[$s]) { $hits += ([regex]::Matches($text, [regex]::Escape($alt))).Count }
      }
    }
    if ($hits -gt 0) {
      $skillName = $meta.skill
      $weight = $meta.weight
      $level = 0
      if ($agent.skills.ContainsKey($skillName)) { $level = $agent.skills[$skillName] }
      # contribution: level * weight * log(1+hits)
      $score += $level * $weight * [math]::Log(1 + $hits)
    }
  }
  return [math]::Round($score,2)
}

# Estimate points per item (fallback 1)
function Get-ItemPoints($item) {
  if ($item.PSObject.Properties['points']) {
    try { return [int]$item.points } catch { }
  }
  if ($item.PSObject.Properties['estimate']) {
    try { return [int]$item.estimate } catch { }
  }
  return 1
}

## Use the reusable assignment engine to map items -> agents


# persist agents config for the assigner (also keep file for inspection)
$agentsConfigPath = Join-Path $root '.continue\three_agents_config.json'
$agents | ConvertTo-Json -Depth 6 | Set-Content -Path $agentsConfigPath -Encoding UTF8

# Call the shared assigner function directly by dot-sourcing the script
$assignerPath = Resolve-Path (Join-Path $root 'scripts\assign_tasks_by_skill.ps1')
. $assignerPath.Path

$tempAssignJson = Join-Path $root '.continue\assignments_temp.json'
$tempAssignTxt = Join-Path $root '.continue\assignments_temp.txt'

$assignOut = Invoke-AssignTasks -BacklogPathParam $backlogPath -AgentsConfigPathParam $agentsConfigPath -OutJsonParam $tempAssignJson -OutTxtParam $tempAssignTxt
if ($null -eq $assignOut) { Write-Error "AssignTasks failed or returned no output" ; exit 2 }

# aggregate per-agent assigned points
foreach ($a in $agents) { $a.assignedPoints = 0 }
foreach ($as in $assignOut.assignments) {
    if ($as.assignedTo) {
        $ag = $agents | Where-Object { $_.name -eq $as.assignedTo }
        if ($ag) { $ag.assignedPoints += [double]$as.points }
    }
}

# build standard output payload (use unique variable name to avoid scope collisions)
$payload = [PSCustomObject]@{
  generated = (Get-Date).ToString('o')
  agents = $agents | ForEach-Object { [PSCustomObject]@{ name = $_.name; capacity = $_.capacity; assignedPoints = $_.assignedPoints } }
  assignments = $assignOut.assignments
}

$outJsonPath = Join-Path $root '.continue\three_agent_simulation.json'
$outTxtPath = Join-Path $root '.continue\three_agent_assignments.txt'

($payload | ConvertTo-Json -Depth 6) | Set-Content -Path $outJsonPath -Encoding UTF8

# Human readable
$lines = @()
$lines += "Three-agent assignment - generated: $((Get-Date).ToString('o'))"
foreach ($a in $payload.agents) { $lines += "Agent: $($a.name) assignedPoints=$($a.assignedPoints)/$($a.capacity)" }
$lines += ""
$lines += "Assignments:"
foreach ($as in $payload.assignments) { $lines += "[$($as.assignedTo)] ($($as.points)pt) $($as.title)" }

$lines | Out-File -FilePath $outTxtPath -Encoding utf8

Write-Host "Wrote $outJsonPath and $outTxtPath"
